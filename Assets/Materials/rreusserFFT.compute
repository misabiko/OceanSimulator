//https://github.com/rreusser/glsl-fft/blob/master/index.glsl
#pragma kernel CSMain

//For some reason, this is 0
// const float TWOPI = 6.283185307179586;

Texture2D<float4> src;
RWTexture2D<float4> output;

float2 resolution;
float subtransformSize;
bool horizontal;
bool forward;
float normalization;

float2 test;
float2 test2;
float2 test3;
float2 test4;
float2 test5;

float customFloor(float a) {
	if (a < 0.0)
		return -ceil(-a);
	else
		return floor(a);
}

float mod(float a, float b) {
	return a - b * customFloor(a / b);
}

[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID) {
	float TWOPI = 6.283185307179586;

	float2 evenPos, oddPos, twiddle, outputA, outputB;
	float4 even, odd;
	float index, evenIndex, twiddleArgument;

	float2 idf = float2(id.x, id.y);

	index = (horizontal ? idf.x : idf.y) - 0.5 + test4.x;

	//Added 0.5 inside the floor
	evenIndex = customFloor(index / subtransformSize) * (subtransformSize * 0.5) +
		fmod(index + test5.y, subtransformSize * 0.5) +
		0.5 + test4.y;

	if (horizontal)
	{
		evenPos = float2(evenIndex, idf.y);
		oddPos = float2(evenIndex, idf.y);
	}
	else
	{
		evenPos = float2(idf.x, evenIndex);
		oddPos = float2(idf.x, evenIndex);
	}

	//divide by width/height
	evenPos *= resolution;
	oddPos *= resolution;

	//TODO Not hardcode
	if (horizontal)
		oddPos.x += 0.5;
	else
		oddPos.y += 0.5;

	evenPos = saturate(evenPos);
	oddPos = saturate(oddPos);

	even = src[evenPos / resolution];
	odd = src[oddPos / resolution];

	twiddleArgument = (forward ? TWOPI : -TWOPI) * (index / subtransformSize);
	twiddle = float2(cos(twiddleArgument), sin(twiddleArgument));

	output[id.xy] = (even.rgba + float4(
		twiddle.x * odd.xz - twiddle.y * odd.yw,
		twiddle.y * odd.xz + twiddle.x * odd.yw
	).xzyw) * normalization;
}