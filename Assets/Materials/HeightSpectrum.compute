#pragma kernel CSMain

//Height frequencies
RWTexture2D<float4> HX;
RWTexture2D<float4> HY;
RWTexture2D<float4> HZ;
//Slope frequencies
// RWTexture2D<float4> NX;
RWTexture2D<float4> NY;
// RWTexture2D<float4> NZ;

RWTexture2D<float4> WaveNumber;
//TODO Readonly texture
Texture2D<float4> Noise;

float Resolution;
//Patch world size
float L;
float F;
float U10;
float gamma;

float phillipsA;
float phillipsSmallLength;
float2 phillipsWindDir;

float time;

//TODO Is there a better way to define PI?
float PI;
float g;

float heightTest;

float2 test;
float2 test2;
float2 test3;
float2 test4;
float2 test5;

float energySpectrum(float w)
{
	// float F = 1400000;
	// float U10 = 20;
	float wp = 22 * pow((g * g) / (U10 * F), 1.0 / 3.0);
	float s = wp <= w ? 0.07f : 0.09f;
	float r = exp(-pow(w - wp, 2) / (2 * s * s * wp * wp));
	float alpha = 0.076f * pow((U10 * U10) / (F * g), 0.22f);
	// float gamma = 3.3f;
	return (alpha * g * g) / pow(w, 5) * exp(-5.0 / 4.0 * pow(wp / w, 4)) * pow(gamma, r);
}

float dispersionRelation(float w)
{
	return 1.0;
}

float phillipsSpectrum(float2 k)
{
	float V = U10;
	float kLen = length(k);
	return phillipsA * (exp(-1 / pow((kLen * (V * V / g)), 2)) / pow(kLen, 4)) * pow(abs(dot(normalize(k), normalize(phillipsWindDir))), 2) * exp(-pow(kLen * phillipsSmallLength, 2));
}

float2 h0(float2 noise, float2 k, float omega)
{
	float domega = g / (2 * omega);
	float deltaK = 2 * PI / L;
	return 1.0 / sqrt(2) * noise * sqrt(2 * energySpectrum(omega) /** dispersionRelation(w) * domega * 1.0 / length(k) * deltaK * deltaK*/);
	// return 1.0 / sqrt(2.0) * noise * sqrt(phillipsSpectrum(k));
}

float2 complexMul(float2 a, float2 b)
{
	return float2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

//TODO Better name than hf?
//hf(k, t) = h0(k) * e^(iwt) + h0(-k) * e^(-iwt) (tess#43)
float2 hf(float omega, float2 h0, float h0Conjugate)
{
	return complexMul(h0, float2(cos(omega * time), sin(omega * time))) + complexMul(h0Conjugate, float2(cos(-omega * time), sin(-omega * time)));
}

[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	float epsilon = 0.0000001;

	//Adding epsilon to avoid k being null
	float2 k = 2.0 * PI * float2(id.x - Resolution / 2, id.y - Resolution / 2) / L + float2(epsilon, epsilon);

	float omega = sqrt(g * length(k));
	WaveNumber[id.xy] = float4(omega / sqrt(g * 2.0 * PI * Resolution / 2.0 / L), 0, 0, 0);

	float2 h0y = h0(Noise[id.xy].xy, k, omega);
	float2 h0ymk = h0(Noise[id.xy].xy, -k, omega);
	float2 hy = hf(omega, h0y, h0ymk);
	HY[id.xy] = float4(hy, 0, 0);

	float2 hx = hf(omega,
		float2(-k.x / length(k) * h0y.y, k.x / length(k) * h0y.x),
		float2(k.x / length(k) * h0ymk.y, -k.x / length(k) * h0ymk.x)
	);
	HX[id.xy] = float4(hx, 0, 0);

	float2 hz = hf(omega,
		float2(-k.y / length(k) * h0y.y, k.y / length(k) * h0y.x),
		float2(k.y / length(k) * h0ymk.y, -k.y / length(k) * h0ymk.x)
	);
	HZ[id.xy] = float4(hz, 0, 0);

	float2 ikx = float2(0, k.x);
	float2 ikz = float2(0, k.y);
	float2 nyx = complexMul(ikx, hy);
	float2 nyz = complexMul(ikz, hy);
	NY[id.xy] = float4(nyx, nyz);
}
