#pragma kernel CSMain

RWTexture2D<float4> HX;
RWTexture2D<float4> HY;
RWTexture2D<float4> HZ;
RWTexture2D<float4> HX2;
RWTexture2D<float4> HY2;
RWTexture2D<float4> HZ2;
RWTexture2D<float4> WaveNumber;
//TODO Readonly texture
Texture2D<float4> Noise;

float Resolution;
float L;
float F;
float U10;
float gamma;

float time;

//TODO Is there a better way to define PI?
float PI;
float g;

float heightTest;

float2 test;
float2 test2;
float2 test3;
float2 test4;
float2 test5;

float energySpectrum(float w) {
	// float F = 1400000;
	// float U10 = 20;
	float wp = 22 * pow((g * g) / (U10 * F), 1.0 / 3.0);
	float s = wp <= w ? 0.07f : 0.09f;
	float r = exp(-pow(w - wp, 2) / (2 * s * s * wp * wp));
	float alpha = 0.076f * pow((U10*U10) / (F * g), 0.22f);
	// float gamma = 3.3f;
	return (alpha * g * g) / pow(w, 5) * exp(-5.0 /4.0 * pow(wp / w, 4)) * pow(gamma, r);
}

float dispersionRelation(float w) {
	return 1.0;
}

float2 h0(float2 noise, float2 k) {
	float w = sqrt(g * length(k));
	float dw = g / (2 * sqrt(g * length(k)));
	float deltaK = 2 * PI / L;
	return 1.0 / sqrt(2) * noise * sqrt(2 * energySpectrum(w) /** dispersionRelation(w) * dw * 1.0 / length(k) * deltaK * deltaK*/);
}

float2 complexMul(float2 a, float2 b) {
	return float2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID) {
	float idx = id.x / Resolution;
	float idy = id.y / Resolution;

	float2 k = 2.0 * PI * (float2(id.x - Resolution / 2.0, id.y - Resolution / 2.0)) / L;
	WaveNumber[id.xy] = float4(k, 0, 0);

	float w = sqrt(g * length(k));

	//float2(r, i)
	float2 h0y = h0(Noise[id.xy].xy, k);
	float2 h0ymk = h0(Noise[id.xy].xy, -k);
	float2 hy = complexMul(h0y, float2(cos(w * time), sin(w * time))) + complexMul(h0ymk, float2(cos(-w * time), sin(-w * time)));
	if (id.x >= test.x && id.x <= test.x + test2.x && id.y >= test.y && id.y <= test.y + test2.y)
		HY[id.xy] = float4(test3, 0.0, 0.0);
	else {
		HY[id.xy] = float4(hy.x, hy.y, 0, 0) * test4.y;
		// HY[id.xy] = float4(0, 0, 0, 0);
	}
	// HY2[id.xy] = float4(hy.x, hy.y, 0, 0) * test4.y;
	
	float2 h0x = float2(-k.x / length(k) * h0y.y, k.x / length(k) * h0y.x);
	float2 h0xmk = float2(k.x / length(k) * h0ymk.y, -k.x / length(k) * h0ymk.x);
	float2 hx = complexMul(h0x, float2(cos(w * time), sin(w * time))) + complexMul(h0xmk, float2(cos(-w * time), sin(-w * time)));
	HX[id.xy] = float4(hx.x, hx.y, 0, 0);
	
	float2 h0z = float2(-k.y / length(k) * h0y.y, k.y / length(k) * h0y.x);
	float2 h0zmk = float2(k.y / length(k) * h0ymk.y, -k.y / length(k) * h0ymk.x);
	float2 hz = complexMul(h0z, float2(cos(w * time), sin(w * time))) + complexMul(h0zmk, float2(cos(-w * time), sin(-w * time)));
	HZ[id.xy] = float4(hz.x, hz.y, 0, 0);
}